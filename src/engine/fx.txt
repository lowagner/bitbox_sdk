rotation : 
u= x a cos + y a sin
v=-x a sin + x a cos

donc boucle du genre : 

y' = ...
xstart= ..
xend = .

for x in range (xstart, xend) : 
	x' = y*asin + x*acos
	y' = y*acos - x*asin 
	linebuf[x+xstart]=img[u,v]

soit 
u =..
v = xstart*acos+yasin ...

for (i=xstart,i<xstart,i++)	:
	u += acos
	v += asin
	k = int(v)*img_w + int(u)
	*dst++ = img[k]

donc 

(unrolled au moins manuellement par deux pour les acces) : NON auto
fixed point arithmetic : use short _Accum

for (i=xstart,i<xstart,i++)	:
	u,v += acos,asin (1 cycle : dual 16bit add)
	k = v>>8   : 1 cyc
	k *= img_w : 1 cyc
	k += u>>8  : 1 cyc
	x = img[k] : 2 cyc
	cmp x,TRANSP (opt) : 1 cyc
	IT *dst++ = x : 2 cyc (amorti en fn du nb de clairs!)

7 cycles, x2 = 12 cycles par 2 pixels hors loop+ 2 pr loop mini
640 pixels = 320*14 = 4480 cycles hors loop vs 5000 ~ ok !
	en basse Q : parfait.


cas scal√© horizontalement (verticalement, + facile !)

(unrolled au moins manuellement par deux pour les acces)
xstart,
k = int(vstart+w)<<8 : non fixed point arith 
ustart=0 (<<8)
for (i=xstart,i<xend,i+=2)	: 1cy, unroll : moins.
	k1,k2 += a,a  1cy (D16ADD)
	x = img[k1] : 2cy 
	y = img[k2] : 2cy
	z = pack(x,y), 1 cyc
	cmp z,transp 1 cyc
	IT : *dst++ = z : 2cyc 

9cy/2pix, 640 : 2500 pix ! 

pour une transparence avec des lignes de c 
utiliser SHADD16 : 

c = h1,h2
for (x=xstart, xend, x+=2)
	*dst = (*dst + c)>>1 dual 16 bits add with ..
	d = load dst = d1,d2 cycles : 1 / pixel
	r = d1+h1/2,d2+h2/2  cycles : 1/2 
	sto r, dst++		 cycles : 1/2
	
loop (loop jnz unroll, amorti a 1 cycle ?)

et donc : 5 cycles / 2 pixels, 640 =>  cycles. 
si on combine load from BG & blit, encore mieux mais + complexe.

distorsions, FX : ..


distorsion : 
	calculer le vecteur avec un algo : twisted 


autres FX : 
	inverse une fois sur deux (sorte de flou, a tester)

	lignes paires : 
	load X1, X2 (words)
	sto X1
	sto X2 ROR 16
	
	lignes impaires : 
	load X1, X2
	sto X1 ROR 16
	sto X2
	
sine verticales (facile)
twisters
...

use hot, __builtin_expect

rle ou blit ou blit inverse (bof)
