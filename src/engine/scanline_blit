Archi generique de blitting optimisé
	-> particulariser les fn elles mêmes


object : 
	x,y,frame

	rasterize_opaque() : calls make_opaque de la liste
	real_blit(pos, len) : blitte opaque réeelement (pos : pa rrapport debut ligne)
	rasterize_transp() : update the buffer
	start_frame()




Objectlist : tries par Y croissant pr activer
active_objects_list : tries par Z croissant
draw_buffer
opaque_list : liste de opaques : liste triee de len, pos opaques, triee. peut etre mergee.
	make_opaque (x,len, &real_blit(x,len))) (decoupe et blitte reellement)
	reset()

blit_line : 
	raster opaque de front a back
	raster transp de back a front, avec 

Zbuffer ou pas (utile pour blitter les transp.)
	si hypothese que transp au dessus des opaque OK


// plus : scanline store
RLE
	+transp, 24bit color ! (en fait dither auto, R8G8B8 -> 0xrgb selon la ligne !!!)
	YES bon
	dither : 
		c + matrix de tramage 2x2 1/5*(1 3)
		                               4 2
	une ligne sur deux
	et C peut lui-même etre un _gradient 2D ds un quad_ ?

	
scanliner : 


scanline blitters : 
	packbit : blits/rle (et aussi blits DMA) (rle+ avec t=1 ou 2)
		1 type blit/rle
		1 repeatlen(pr repeat : 2 ou 4 pixels) - permet le dither 
		transp(=1 couleur)
		7 size
		7 skip

	+1 word data ou 2






	Autodither : sierra lite (see http://www.tannerhelland.com/4660/dithering-eleven-algorithms-source-code/)
		interet : permet des primitives grpahiques plus élevées : a combiner avec des RLE ou gradients par ex !

	4-patterns (repeat of a pattern of 4 pixels) : comme dither mais + simple.

	2-cols via 


	dither
		sur le blits, le dithering peut etre automatique depuis 15bits vers 12b : enleve 1 bit par 
		load 2 pixels as RGB32 00RRGGBB
		ajouter sur 2 pixels, les 3 elements - 01110222 pour lignes paires (RGB),  pour lignes impaires, diviser ss reste (shift) 

		swar dither : http://chessprogramming.wikispaces.com/SIMD+and+SWAR+Techniques
		et donc : 

		SWAR add z = x + y
    	z = ((x &~H) + (y &~H)) ^ ((x ^ y) & H) (pour 6 composantes)

    	et comme Y est connu et n'a pas de BPF : 
    	z = ((x &~H) + y)) ^ ((x ^ y) & H)
    	5 ops pour 32 bits = 2 pixels + load et store
    	8 ops, et 640*8/2 = KO + z a passer en 15bits apres : facile, shifts. voire rien

    	ie 0x0rgb0rgb : pas de packing alors que QADD necessite un pack/unpack.


    	sur un RLE : facile car 2 pix à la fois. sur un gradient, + dur
    	2dither en RLE : OK pour gradient horizontal mais pas vertical. bizarre peut etre ; à voir
    	blitter scanline
		


objects : 
	sprites
	tileset
	linemap
	quads
	convex polys
	hexagons
	

	
	type de blit par objet
	packbit
	Linear gradient (+ dithering) : oui, direct, position

	packbit scaled, rotozoom
	dithering : 1D, 1bit dither image, alternée (G-D et D-G) ? non 15 bits + simple
	Lines (avec bresenham)


	permet du dithering



scanline rendering transparence
	blitter devant opaque->fond opaque & blitter aussi transparent 
	


physical : 
	heat
	ventilo


unpack from RAM 
	rgb = 12bits, 1 word = 32bits (faster reads)
	1 word = 32 bits
	ppcm 12/32=96 (3words, 8pixels) au lieu de 4

	unpack : 
	0xrgbr gbrg , brgb rgbr, gbrg brgb
	dc : 
	0x0rgb : 
